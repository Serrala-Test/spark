/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.streaming.api.java

import com.google.common.base.Optional

import org.apache.spark.Partitioner
import org.apache.spark.annotation.Experimental
import org.apache.spark.api.java.{JavaPairRDD, JavaUtils}
import org.apache.spark.api.java.function.{Function2 => JFunction2, Function4 => JFunction4}
import org.apache.spark.streaming.{Time, Duration, State, StateSpec}

/**
 * :: Experimental ::
 * Class representing all the specifications of the [[JavaDStream]] transformation
 * `trackStateByKey` operation of a [[JavaPairDStream]].
 * Use the [[JavaStateSpec.function()]] to create instances of this class.
 *
 * Example:
 * {{{
 *    JavaStateSpec[KeyType, ValueType, StateType, EmittedDataType] spec =
 *      JavaStateSpec.function[KeyType, ValueType, StateType, EmittedDataType](trackingFunction)
 *                    .numPartition(10);
 *
 *    JavaTrackStateDStream[KeyType, ValueType, StateType, EmittedType] emittedRecordDStream =
 *      javaPairDStream.trackStateByKey[StateType, EmittedDataType](spec);
 * }}}
 */
@Experimental
final class JavaStateSpec[K, V, S, T](
    private[streaming] val stateSpec: StateSpec[K, V, S, T]) extends Serializable {

  /** Set the RDD containing the initial states that will be used by `trackStateByKey` */
  def initialState(javaPairRDD: JavaPairRDD[K, S]): this.type = {
    stateSpec.initialState(javaPairRDD.rdd)
    this
  }

  /**
   * Set the number of partitions by which the state RDDs generated by `trackStateByKey`
   * will be partitioned. Hash partitioning will be used.
   */
  def numPartitions(numPartitions: Int): this.type = {
    stateSpec.numPartitions(numPartitions)
    this
  }

  /**
   * Set the partitioner by which the state RDDs generated by `trackStateByKey` will be
   * be partitioned.
   */
  def partitioner(partitioner: Partitioner): this.type = {
    stateSpec.partitioner(partitioner)
    this
  }

  /**
   * Set the duration after which the state of an idle key will be removed. A key and its state is
   * considered idle if it has not received any data for at least the given duration. The state
   * tracking function will be called one final time on the idle states that are going to be
   * removed; [[JavaState.isTimingOut()]] set to `true` in that call.
   */
  def timeout(interval: Duration): this.type = {
    stateSpec.timeout(interval)
    this
  }
}


/**
 * :: Experimental ::
 * Builder object for creating instances of [[JavaStateSpec]] that is used for specifying the
 * parameters of the DStream transformation `trackStateByKey` operation of a [[JavaPairDStream]].
 *
 * Example:
 * {{{
 *    JavaStateSpec[KeyType, ValueType, StateType, EmittedDataType] spec =
 *      JavaStateSpec.function[KeyType, ValueType, StateType, EmittedDataType](trackingFunction)
 *                    .numPartition(10);
 *
 *    JavaTrackStateDStream[KeyType, ValueType, StateType, EmittedType] emittedRecordDStream =
 *      javaPairDStream.trackStateByKey[StateType, EmittedDataType](spec);
 * }}}
 */
@Experimental
final object JavaStateSpec {

  /**
   * Create a [[JavaStateSpec]] for setting all the specifications `trackStateByKey` operation on a
   * [[JavaPairDStream]].
   *
   * @param javaTrackingFunction The function applied on every data item to manage the associated
   *                             state and generate the emitted data
   * @tparam KeyType      Class of the keys
   * @tparam ValueType    Class of the values
   * @tparam StateType    Class of the states data
   * @tparam EmittedType  Class of the emitted data
   */
  def function[KeyType, ValueType, StateType, EmittedType](javaTrackingFunction:
      JFunction4[Time, KeyType, Optional[ValueType], JavaState[StateType], Optional[EmittedType]]):
    JavaStateSpec[KeyType, ValueType, StateType, EmittedType] = {
    val trackingFunc = (time: Time, k: KeyType, v: Option[ValueType], s: State[StateType]) => {
      val t = javaTrackingFunction.call(time, k, JavaUtils.optionToOptional(v), new JavaState(s))
      Option(t.orNull)
    }
    new JavaStateSpec(StateSpec.function(trackingFunc))
  }

  /**
   * Create a [[JavaStateSpec]] for setting all the specifications `trackStateByKey` operation on a
   * [[JavaPairDStream]].
   *
   * @param javaTrackingFunction The function applied on every data item to manage the associated
   *                             state and generate the emitted data
   * @tparam ValueType    Class of the values
   * @tparam StateType    Class of the states data
   * @tparam EmittedType  Class of the emitted data
   */
  def function[KeyType, ValueType, StateType, EmittedType](
      javaTrackingFunction: JFunction2[Optional[ValueType], JavaState[StateType], EmittedType]):
    JavaStateSpec[KeyType, ValueType, StateType, EmittedType] = {
    val trackingFunc = (v: Option[ValueType], s: State[StateType]) => {
      javaTrackingFunction.call(Optional.fromNullable(v.get), new JavaState(s))
    }
    new JavaStateSpec(StateSpec.function(trackingFunc))
  }
}
