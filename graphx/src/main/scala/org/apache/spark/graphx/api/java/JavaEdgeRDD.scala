/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.spark.graphx.api.java

import java.lang.{Long => JLong}
import java.util.{List => JList}

import org.apache.spark.api.java.JavaRDD
import org.apache.spark.api.java.function.{Function => JFunction}
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
import org.apache.spark.storage.StorageLevel

import scala.language.implicitConversions
import scala.reflect.ClassTag

/**
 * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].
 * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class
 *
 * @param targetStorageLevel
 * @tparam ED
 */
class JavaEdgeRDD[ED](
    val edges: RDD[Edge[ED]],
    val targetStorageLevel: StorageLevel = StorageLevel.MEMORY_ONLY)
    (implicit val classTag: ClassTag[ED])
  extends JavaEdgeRDDLike[ED, JavaEdgeRDD[ED], JavaRDD[(VertexId, VertexId, ED)]] {

//  /**
//   * To create JavaEdgeRDD from JavaRDDs of tuples
//   * (source vertex id, destination vertex id and edge property class).
//   * The edge property class can be Array[Byte]
//   * @param jEdges
//   */
//  def this(jEdges: JavaRDD[(VertexId, VertexId, ED)]) = {
//    this(jEdges.rdd.map(x => Edge[ED](x._1, x._2, x._3)))
//  }

  /* Convert RDD[(PartitionID, EdgePartition[ED, VD])] to EdgeRDD[ED, VD] */
  override def edgeRDD = EdgeRDD.fromEdges(edges)

  /**
   * Java Wrapper for RDD of Edges
   *
   * @param edgeRDD
   * @return
   */
  def wrapRDD(edgeRDD: RDD[Edge[ED]]): JavaRDD[Edge[ED]] = {
    JavaRDD.fromRDD(edgeRDD)
  }

  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */
  def cache(): this.type = {
    edges.cache()
    this
  }

  def collect(): JList[Edge[ED]] = {
    import scala.collection.JavaConversions._
    val arr: java.util.Collection[Edge[ED]] = edges.collect().toSeq
    new java.util.ArrayList(arr)
  }

  /**
   * Return a new single long element generated by counting all elements in the vertex RDD
   */
  override def count(): JLong = edges.count()

  /** Return a new VertexRDD containing only the elements that satisfy a predicate. */
  def filter(f: JFunction[Edge[ED], Boolean]): JavaEdgeRDD[ED] =
    JavaEdgeRDD(edgeRDD.filter(x => f.call(x).booleanValue()))

  def id: JLong = edges.id.toLong

  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */
  def persist(): this.type = {
    edges.persist()
    this
  }

  /** Persist the RDDs of this EdgeRDD with the given storage level */
  def persist(storageLevel: StorageLevel): this.type = {
    edges.persist(storageLevel)
    this
  }

  def unpersist(blocking: Boolean = true) : this.type = {
    edgeRDD.unpersist(blocking)
    this
  }

  override def mapValues[ED2: ClassTag](f: Edge[ED] => ED2): JavaEdgeRDD[ED2] = {
    JavaEdgeRDD(edgeRDD.mapValues(f))
  }

  override def reverse: JavaEdgeRDD[ED] = JavaEdgeRDD(edgeRDD.reverse)

  def innerJoin[ED2: ClassTag, ED3: ClassTag]
    (other: EdgeRDD[ED2])
    (f: (VertexId, VertexId, ED, ED2) => ED3): JavaEdgeRDD[ED3] = {
    JavaEdgeRDD(edgeRDD.innerJoin(other)(f))
  }

  def toRDD : RDD[Edge[ED]] = edges
}

object JavaEdgeRDD {

  implicit def apply[ED: ClassTag](edges: JavaRDD[Edge[ED]]) : JavaEdgeRDD[ED] = {
    JavaEdgeRDD(EdgeRDD.fromEdges(edges.rdd))
  }

  def toEdgeRDD[ED: ClassTag](edges: JavaEdgeRDD[ED]): RDD[Edge[ED]] = {
    JavaEdgeRDD(edges.edgeRDD).toRDD
  }

//  def apply[ED: ClassTag](
//    jEdges: JavaRDD[(VertexId, VertexId, ED)]): JavaEdgeRDD[ED] = {
//    val edges : RDD[Edge[ED]] = jEdges.rdd.map(x => Edge(x._1, x._2, x._3))
//    new JavaEdgeRDD(edges)
//  }
}

