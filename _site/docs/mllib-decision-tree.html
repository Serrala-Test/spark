<ul id="markdown-toc">
  <li><a href="#basic-algorithm">Basic algorithm</a>    <ul>
      <li><a href="#node-impurity-and-information-gain">Node impurity and information gain</a></li>
      <li><a href="#split-candidates">Split candidates</a></li>
      <li><a href="#stopping-rule">Stopping rule</a></li>
    </ul>
  </li>
  <li><a href="#implementation-details">Implementation details</a>    <ul>
      <li><a href="#max-memory-requirements">Max memory requirements</a></li>
      <li><a href="#binning-feature-values">Binning feature values</a></li>
      <li><a href="#scaling">Scaling</a></li>
    </ul>
  </li>
  <li><a href="#examples">Examples</a>    <ul>
      <li><a href="#classification">Classification</a></li>
      <li><a href="#regression">Regression</a></li>
    </ul>
  </li>
</ul>

<p><a href="http://en.wikipedia.org/wiki/Decision_tree_learning">Decision trees</a>
and their ensembles are popular methods for the machine learning tasks of
classification and regression. Decision trees are widely used since they are easy to interpret,
handle categorical features, extend to the multiclass classification setting, do not require
feature scaling and are able to capture nonlinearities and feature interactions. Tree ensemble
algorithms such as random forests and boosting are among the top performers for classification and
regression tasks.</p>

<p>MLlib supports decision trees for binary and multiclass classification and for regression,
using both continuous and categorical features. The implementation partitions data by rows,
allowing distributed training with millions of instances.</p>

<h2 id="basic-algorithm">Basic algorithm</h2>

<p>The decision tree is a greedy algorithm that performs a recursive binary partitioning of the feature
space.  The tree predicts the same label for each bottommost (leaf) partition.
Each partition is chosen greedily by selecting the <em>best split</em> from a set of possible splits,
in order to maximize the information gain at a tree node. In other words, the split chosen at each
tree node is chosen from the set <code>$\underset{s}{\operatorname{argmax}} IG(D,s)$</code> where <code>$IG(D,s)$</code>
is the information gain when a split <code>$s$</code> is applied to a dataset <code>$D$</code>.</p>

<h3 id="node-impurity-and-information-gain">Node impurity and information gain</h3>

<p>The <em>node impurity</em> is a measure of the homogeneity of the labels at the node. The current
implementation provides two impurity measures for classification (Gini impurity and entropy) and one
impurity measure for regression (variance).</p>

<table class="table">
  <thead>
    <tr><th>Impurity</th><th>Task</th><th>Formula</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>Gini impurity</td>
	  <td>Classification</td>
	  <td>$\sum_{i=1}^{M} f_i(1-f_i)$</td><td>$f_i$ is the frequency of label $i$ at a node and $M$ is the number of unique labels.</td>
    </tr>
    <tr>
      <td>Entropy</td>
	  <td>Classification</td>
	  <td>$\sum_{i=1}^{M} -f_ilog(f_i)$</td><td>$f_i$ is the frequency of label $i$ at a node and $M$ is the number of unique labels.</td>
    </tr>
    <tr>
      <td>Variance</td>
	  <td>Regression</td>
     <td>$\frac{1}{n} \sum_{i=1}^{N} (x_i - \mu)^2$</td><td>$y_i$ is label for an instance,
	  $N$ is the number of instances and $\mu$ is the mean given by $\frac{1}{N} \sum_{i=1}^n x_i$.</td>
    </tr>
  </tbody>
</table>

<p>The <em>information gain</em> is the difference between the parent node impurity and the weighted sum of
the two child node impurities. Assuming that a split $s$ partitions the dataset <code>$D$</code> of size <code>$N$</code>
into two datasets <code>$D_{left}$</code> and <code>$D_{right}$</code> of sizes <code>$N_{left}$</code> and <code>$N_{right}$</code>,
respectively, the information gain is:</p>

<p><code>$IG(D,s) = Impurity(D) - \frac{N_{left}}{N} Impurity(D_{left}) - \frac{N_{right}}{N} Impurity(D_{right})$</code></p>

<h3 id="split-candidates">Split candidates</h3>

<p><strong>Continuous features</strong></p>

<p>For small datasets in single-machine implementations, the split candidates for each continuous
feature are typically the unique values for the feature. Some implementations sort the feature
values and then use the ordered unique values as split candidates for faster tree calculations.</p>

<p>Sorting feature values is expensive for large distributed datasets.
This implementation computes an approximate set of split candidates by performing a quantile
calculation over a sampled fraction of the data.
The ordered splits create “bins” and the maximum number of such
bins can be specified using the <code>maxBins</code> parameter.</p>

<p>Note that the number of bins cannot be greater than the number of instances <code>$N$</code> (a rare scenario
since the default <code>maxBins</code> value is 32). The tree algorithm automatically reduces the number of
bins if the condition is not satisfied.</p>

<p><strong>Categorical features</strong></p>

<p>For a categorical feature with <code>$M$</code> possible values (categories), one could come up with
<code>$2^{M-1}-1$</code> split candidates. For binary (0/1) classification and regression,
we can reduce the number of split candidates to <code>$M-1$</code> by ordering the
categorical feature values by the average label. (See Section 9.2.4 in
<a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/">Elements of Statistical Machine Learning</a> for
details.) For example, for a binary classification problem with one categorical feature with three
categories A, B and C whose corresponding proportions of label 1 are 0.2, 0.6 and 0.4, the categorical
features are ordered as A, C, B. The two split candidates are A | C, B
and A , C | B where | denotes the split.</p>

<p>In multiclass classification, all <code>$2^{M-1}-1$</code> possible splits are used whenever possible.
When <code>$2^{M-1}-1$</code> is greater than the <code>maxBins</code> parameter, we use a (heuristic) method
similar to the method used for binary classification and regression.
The <code>$M$</code> categorical feature values are ordered by impurity,
and the resulting <code>$M-1$</code> split candidates are considered.</p>

<h3 id="stopping-rule">Stopping rule</h3>

<p>The recursive tree construction is stopped at a node when one of the two conditions is met:</p>

<ol>
  <li>The node depth is equal to the <code>maxDepth</code> training parameter.</li>
  <li>No split candidate leads to an information gain at the node.</li>
</ol>

<h2 id="implementation-details">Implementation details</h2>

<h3 id="max-memory-requirements">Max memory requirements</h3>

<p>For faster processing, the decision tree algorithm performs simultaneous histogram computations for
all nodes at each level of the tree. This could lead to high memory requirements at deeper levels
of the tree, potentially leading to memory overflow errors. To alleviate this problem, a <code>maxMemoryInMB</code>
training parameter specifies the maximum amount of memory at the workers (twice as much at the
master) to be allocated to the histogram computation. The default value is conservatively chosen to
be 256 MB to allow the decision algorithm to work in most scenarios. Once the memory requirements
for a level-wise computation cross the <code>maxMemoryInMB</code> threshold, the node training tasks at each
subsequent level are split into smaller tasks.</p>

<p>Note that, if you have a large amount of memory, increasing <code>maxMemoryInMB</code> can lead to faster
training by requiring fewer passes over the data.</p>

<h3 id="binning-feature-values">Binning feature values</h3>

<p>Increasing <code>maxBins</code> allows the algorithm to consider more split candidates and make fine-grained
split decisions.  However, it also increases computation and communication.</p>

<p>Note that the <code>maxBins</code> parameter must be at least the maximum number of categories <code>$M$</code> for
any categorical feature.</p>

<h3 id="scaling">Scaling</h3>

<p>Computation scales approximately linearly in the number of training instances,
in the number of features, and in the <code>maxBins</code> parameter.
Communication scales approximately linearly in the number of features and in <code>maxBins</code>.</p>

<p>The implemented algorithm reads both sparse and dense data. However, it is not optimized for sparse input.</p>

<h2 id="examples">Examples</h2>

<h3 id="classification">Classification</h3>

<p>The example below demonstrates how to load a
<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">LIBSVM data file</a>,
parse it as an RDD of <code>LabeledPoint</code> and then
perform classification using a decision tree with Gini impurity as an impurity measure and a
maximum tree depth of 5. The training error is calculated to measure the algorithm accuracy.</p>

<div class="codetabs">

<div data-lang="scala">

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.mllib.tree.DecisionTree</span>
<span class="k">import</span> <span class="nn">org.apache.spark.mllib.util.MLUtils</span>

<span class="c1">// Load and parse the data file.</span>
<span class="c1">// Cache the data since we will use it again to compute training error.</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">MLUtils</span><span class="o">.</span><span class="n">loadLibSVMFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/mllib/sample_libsvm_data.txt&quot;</span><span class="o">).</span><span class="n">cache</span><span class="o">()</span>

<span class="c1">// Train a DecisionTree model.</span>
<span class="c1">//  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="k">val</span> <span class="n">numClasses</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">categoricalFeaturesInfo</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">impurity</span> <span class="k">=</span> <span class="s">&quot;gini&quot;</span>
<span class="k">val</span> <span class="n">maxDepth</span> <span class="k">=</span> <span class="mi">5</span>
<span class="k">val</span> <span class="n">maxBins</span> <span class="k">=</span> <span class="mi">32</span>

<span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">DecisionTree</span><span class="o">.</span><span class="n">trainClassifier</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">numClasses</span><span class="o">,</span> <span class="n">categoricalFeaturesInfo</span><span class="o">,</span> <span class="n">impurity</span><span class="o">,</span>
  <span class="n">maxDepth</span><span class="o">,</span> <span class="n">maxBins</span><span class="o">)</span>

<span class="c1">// Evaluate model on training instances and compute training error</span>
<span class="k">val</span> <span class="n">labelAndPreds</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">point</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">prediction</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="n">features</span><span class="o">)</span>
  <span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="n">label</span><span class="o">,</span> <span class="n">prediction</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">trainErr</span> <span class="k">=</span> <span class="n">labelAndPreds</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">_1</span> <span class="o">!=</span> <span class="n">r</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">count</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Training Error = &quot;</span> <span class="o">+</span> <span class="n">trainErr</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Learned classification tree model:\n&quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">)</span></code></pre></div>

</div>

<div data-lang="java">

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">scala.Tuple2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaPairRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaSparkContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.PairFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.regression.LabeledPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.tree.DecisionTree</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.tree.model.DecisionTreeModel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.util.MLUtils</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.SparkConf</span><span class="o">;</span>

<span class="n">SparkConf</span> <span class="n">sparkConf</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SparkConf</span><span class="o">().</span><span class="na">setAppName</span><span class="o">(</span><span class="s">&quot;JavaDecisionTree&quot;</span><span class="o">);</span>
<span class="n">JavaSparkContext</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">JavaSparkContext</span><span class="o">(</span><span class="n">sparkConf</span><span class="o">);</span>

<span class="c1">// Load and parse the data file.</span>
<span class="c1">// Cache the data since we will use it again to compute training error.</span>
<span class="n">String</span> <span class="n">datapath</span> <span class="o">=</span> <span class="s">&quot;data/mllib/sample_libsvm_data.txt&quot;</span><span class="o">;</span>
<span class="n">JavaRDD</span><span class="o">&lt;</span><span class="n">LabeledPoint</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">MLUtils</span><span class="o">.</span><span class="na">loadLibSVMFile</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="na">sc</span><span class="o">(),</span> <span class="n">datapath</span><span class="o">).</span><span class="na">toJavaRDD</span><span class="o">().</span><span class="na">cache</span><span class="o">();</span>

<span class="c1">// Set parameters.</span>
<span class="c1">//  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="n">Integer</span> <span class="n">numClasses</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">categoricalFeaturesInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">String</span> <span class="n">impurity</span> <span class="o">=</span> <span class="s">&quot;gini&quot;</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">maxBins</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>

<span class="c1">// Train a DecisionTree model for classification.</span>
<span class="kd">final</span> <span class="n">DecisionTreeModel</span> <span class="n">model</span> <span class="o">=</span> <span class="n">DecisionTree</span><span class="o">.</span><span class="na">trainClassifier</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">numClasses</span><span class="o">,</span>
  <span class="n">categoricalFeaturesInfo</span><span class="o">,</span> <span class="n">impurity</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">,</span> <span class="n">maxBins</span><span class="o">);</span>

<span class="c1">// Evaluate model on training instances and compute training error</span>
<span class="n">JavaPairRDD</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">predictionAndLabel</span> <span class="o">=</span>
  <span class="n">data</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="k">new</span> <span class="n">PairFunction</span><span class="o">&lt;</span><span class="n">LabeledPoint</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="nf">call</span><span class="o">(</span><span class="n">LabeledPoint</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;(</span><span class="n">model</span><span class="o">.</span><span class="na">predict</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">features</span><span class="o">()),</span> <span class="n">p</span><span class="o">.</span><span class="na">label</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">});</span>
<span class="n">Double</span> <span class="n">trainErr</span> <span class="o">=</span>
  <span class="mf">1.0</span> <span class="o">*</span> <span class="n">predictionAndLabel</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Boolean</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">call</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">pl</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="n">pl</span><span class="o">.</span><span class="na">_1</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">pl</span><span class="o">.</span><span class="na">_2</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}).</span><span class="na">count</span><span class="o">()</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Training error: &quot;</span> <span class="o">+</span> <span class="n">trainErr</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Learned classification tree model:\n&quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">);</span></code></pre></div>

</div>

<div data-lang="python">

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pyspark.mllib.regression</span> <span class="kn">import</span> <span class="n">LabeledPoint</span>
<span class="kn">from</span> <span class="nn">pyspark.mllib.tree</span> <span class="kn">import</span> <span class="n">DecisionTree</span>
<span class="kn">from</span> <span class="nn">pyspark.mllib.util</span> <span class="kn">import</span> <span class="n">MLUtils</span>

<span class="c"># Load and parse the data file into an RDD of LabeledPoint.</span>
<span class="c"># Cache the data since we will use it again to compute training error.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">MLUtils</span><span class="o">.</span><span class="n">loadLibSVMFile</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&#39;data/mllib/sample_libsvm_data.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>

<span class="c"># Train a DecisionTree model.</span>
<span class="c">#  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">DecisionTree</span><span class="o">.</span><span class="n">trainClassifier</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numClasses</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">categoricalFeaturesInfo</span><span class="o">=</span><span class="p">{},</span>
                                     <span class="n">impurity</span><span class="o">=</span><span class="s">&#39;gini&#39;</span><span class="p">,</span> <span class="n">maxDepth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxBins</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>

<span class="c"># Evaluate model on training instances and compute training error</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">features</span><span class="p">))</span>
<span class="n">labelsAndPredictions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">lp</span><span class="p">:</span> <span class="n">lp</span><span class="o">.</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
<span class="n">trainErr</span> <span class="o">=</span> <span class="n">labelsAndPredictions</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Training Error = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trainErr</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Learned classification tree model:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span></code></pre></div>


Note: When making predictions for a dataset, it is more efficient to do batch prediction rather
than separately calling `predict` on each data point.  This is because the Python code makes calls
to an underlying `DecisionTree` model in Scala.
</div>

</div>

<h3 id="regression">Regression</h3>

<p>The example below demonstrates how to load a
<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">LIBSVM data file</a>,
parse it as an RDD of <code>LabeledPoint</code> and then
perform regression using a decision tree with variance as an impurity measure and a maximum tree
depth of 5. The Mean Squared Error (MSE) is computed at the end to evaluate
<a href="http://en.wikipedia.org/wiki/Goodness_of_fit">goodness of fit</a>.</p>

<div class="codetabs">

<div data-lang="scala">

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.spark.mllib.tree.DecisionTree</span>
<span class="k">import</span> <span class="nn">org.apache.spark.mllib.util.MLUtils</span>

<span class="c1">// Load and parse the data file.</span>
<span class="c1">// Cache the data since we will use it again to compute training error.</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">MLUtils</span><span class="o">.</span><span class="n">loadLibSVMFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/mllib/sample_libsvm_data.txt&quot;</span><span class="o">).</span><span class="n">cache</span><span class="o">()</span>

<span class="c1">// Train a DecisionTree model.</span>
<span class="c1">//  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="k">val</span> <span class="n">categoricalFeaturesInfo</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">impurity</span> <span class="k">=</span> <span class="s">&quot;variance&quot;</span>
<span class="k">val</span> <span class="n">maxDepth</span> <span class="k">=</span> <span class="mi">5</span>
<span class="k">val</span> <span class="n">maxBins</span> <span class="k">=</span> <span class="mi">32</span>

<span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">DecisionTree</span><span class="o">.</span><span class="n">trainRegressor</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">categoricalFeaturesInfo</span><span class="o">,</span> <span class="n">impurity</span><span class="o">,</span>
  <span class="n">maxDepth</span><span class="o">,</span> <span class="n">maxBins</span><span class="o">)</span>

<span class="c1">// Evaluate model on training instances and compute training error</span>
<span class="k">val</span> <span class="n">labelsAndPredictions</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">point</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">prediction</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="n">features</span><span class="o">)</span>
  <span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="n">label</span><span class="o">,</span> <span class="n">prediction</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">trainMSE</span> <span class="k">=</span> <span class="n">labelsAndPredictions</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="o">((</span><span class="n">v</span> <span class="o">-</span> <span class="n">p</span><span class="o">),</span> <span class="mi">2</span><span class="o">)}.</span><span class="n">mean</span><span class="o">()</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Training Mean Squared Error = &quot;</span> <span class="o">+</span> <span class="n">trainMSE</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Learned regression tree model:\n&quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">)</span></code></pre></div>

</div>

<div data-lang="java">

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">scala.Tuple2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function2</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaPairRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaSparkContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.PairFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.regression.LabeledPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.tree.DecisionTree</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.tree.model.DecisionTreeModel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.mllib.util.MLUtils</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.SparkConf</span><span class="o">;</span>

<span class="c1">// Load and parse the data file.</span>
<span class="c1">// Cache the data since we will use it again to compute training error.</span>
<span class="n">String</span> <span class="n">datapath</span> <span class="o">=</span> <span class="s">&quot;data/mllib/sample_libsvm_data.txt&quot;</span><span class="o">;</span>
<span class="n">JavaRDD</span><span class="o">&lt;</span><span class="n">LabeledPoint</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">MLUtils</span><span class="o">.</span><span class="na">loadLibSVMFile</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="na">sc</span><span class="o">(),</span> <span class="n">datapath</span><span class="o">).</span><span class="na">toJavaRDD</span><span class="o">().</span><span class="na">cache</span><span class="o">();</span>

<span class="n">SparkConf</span> <span class="n">sparkConf</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SparkConf</span><span class="o">().</span><span class="na">setAppName</span><span class="o">(</span><span class="s">&quot;JavaDecisionTree&quot;</span><span class="o">);</span>
<span class="n">JavaSparkContext</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">JavaSparkContext</span><span class="o">(</span><span class="n">sparkConf</span><span class="o">);</span>

<span class="c1">// Set parameters.</span>
<span class="c1">//  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">categoricalFeaturesInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">String</span> <span class="n">impurity</span> <span class="o">=</span> <span class="s">&quot;variance&quot;</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">maxBins</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>

<span class="c1">// Train a DecisionTree model.</span>
<span class="kd">final</span> <span class="n">DecisionTreeModel</span> <span class="n">model</span> <span class="o">=</span> <span class="n">DecisionTree</span><span class="o">.</span><span class="na">trainRegressor</span><span class="o">(</span><span class="n">data</span><span class="o">,</span>
  <span class="n">categoricalFeaturesInfo</span><span class="o">,</span> <span class="n">impurity</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">,</span> <span class="n">maxBins</span><span class="o">);</span>

<span class="c1">// Evaluate model on training instances and compute training error</span>
<span class="n">JavaPairRDD</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">predictionAndLabel</span> <span class="o">=</span>
  <span class="n">data</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="k">new</span> <span class="n">PairFunction</span><span class="o">&lt;</span><span class="n">LabeledPoint</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="nf">call</span><span class="o">(</span><span class="n">LabeledPoint</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;(</span><span class="n">model</span><span class="o">.</span><span class="na">predict</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">features</span><span class="o">()),</span> <span class="n">p</span><span class="o">.</span><span class="na">label</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">});</span>
<span class="n">Double</span> <span class="n">trainMSE</span> <span class="o">=</span>
  <span class="n">predictionAndLabel</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Double</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Double</span> <span class="nf">call</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">pl</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="na">_1</span><span class="o">()</span> <span class="o">-</span> <span class="n">pl</span><span class="o">.</span><span class="na">_2</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}).</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">Function2</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Double</span> <span class="nf">call</span><span class="o">(</span><span class="n">Double</span> <span class="n">a</span><span class="o">,</span> <span class="n">Double</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">})</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Training Mean Squared Error: &quot;</span> <span class="o">+</span> <span class="n">trainMSE</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Learned regression tree model:\n&quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">);</span></code></pre></div>

</div>

<div data-lang="python">

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pyspark.mllib.regression</span> <span class="kn">import</span> <span class="n">LabeledPoint</span>
<span class="kn">from</span> <span class="nn">pyspark.mllib.tree</span> <span class="kn">import</span> <span class="n">DecisionTree</span>
<span class="kn">from</span> <span class="nn">pyspark.mllib.util</span> <span class="kn">import</span> <span class="n">MLUtils</span>

<span class="c"># Load and parse the data file into an RDD of LabeledPoint.</span>
<span class="c"># Cache the data since we will use it again to compute training error.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">MLUtils</span><span class="o">.</span><span class="n">loadLibSVMFile</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="s">&#39;data/mllib/sample_libsvm_data.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>

<span class="c"># Train a DecisionTree model.</span>
<span class="c">#  Empty categoricalFeaturesInfo indicates all features are continuous.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">DecisionTree</span><span class="o">.</span><span class="n">trainRegressor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">categoricalFeaturesInfo</span><span class="o">=</span><span class="p">{},</span>
                                    <span class="n">impurity</span><span class="o">=</span><span class="s">&#39;variance&#39;</span><span class="p">,</span> <span class="n">maxDepth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxBins</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>

<span class="c"># Evaluate model on training instances and compute training error</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">features</span><span class="p">))</span>
<span class="n">labelsAndPredictions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">lp</span><span class="p">:</span> <span class="n">lp</span><span class="o">.</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
<span class="n">trainMSE</span> <span class="o">=</span> <span class="n">labelsAndPredictions</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Training Mean Squared Error = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trainMSE</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Learned regression tree model:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span></code></pre></div>


Note: When making predictions for a dataset, it is more efficient to do batch prediction rather
than separately calling `predict` on each data point.  This is because the Python code makes calls
to an underlying `DecisionTree` model in Scala.
</div>

</div>
