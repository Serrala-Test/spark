/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.expressions

import org.apache.spark.sql.catalyst.InternalRow
import org.apache.spark.sql.catalyst.CatalystTypeConverters
import org.apache.spark.sql.catalyst.expressions.codegen._
import org.apache.spark.sql.types.DataType

/**
 * User-defined function.
 * @param dataType  Return type of function.
 */
case class ScalaUDF(
    function: AnyRef,
    dataType: DataType,
    children: Seq[Expression],
    inputTypes: Seq[DataType] = Nil)
  extends Expression with ImplicitCastInputTypes {

  override def nullable: Boolean = true

  override def toString: String = s"UDF(${children.mkString(",")})"

  // scalastyle:off

  /** This method has been generated by this script

    (1 to 22).map { x =>
      val anys = (1 to x).map(x => "Any").reduce(_ + ", " + _)
      val childs = (0 to x - 1).map(x => s"val child$x = children($x)").reduce(_ + "\n  " + _)
      val converters = (0 to x - 1).map(x => s"lazy val converter$x = CatalystTypeConverters.createToScalaConverter(child$x.dataType)").reduce(_ + "\n  " + _)
      val evals = (0 to x - 1).map(x => s"converter$x(child$x.eval(input))").reduce(_ + ",\n      " + _)

      s"""case $x =>
      val func = function.asInstanceOf[($anys) => Any]
      $childs
      $converters
      (input: InternalRow) => {
        func(
          $evals)
      }
      """
    }.foreach(println)

  */

  // Accessors used in genCode
  def userDefinedFunc(): AnyRef = function
  def getChildren(): Seq[Expression] = children

  private[this] val f = children.size match {
    case 0 =>
      val func = function.asInstanceOf[() => Any]
      (input: InternalRow) => {
        func()
      }

    case 1 =>
      val func = function.asInstanceOf[(Any) => Any]
      val child0 = children(0)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)))
      }

    case 2 =>
      val func = function.asInstanceOf[(Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)))
      }

    case 3 =>
      val func = function.asInstanceOf[(Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)))
      }

    case 4 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)))
      }

    case 5 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)))
      }

    case 6 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)))
      }

    case 7 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)))
      }

    case 8 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)))
      }

    case 9 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)))
      }

    case 10 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)))
      }

    case 11 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)))
      }

    case 12 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)))
      }

    case 13 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)))
      }

    case 14 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)))
      }

    case 15 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)))
      }

    case 16 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)))
      }

    case 17 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)))
      }

    case 18 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)))
      }

    case 19 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)))
      }

    case 20 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)))
      }

    case 21 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)))
      }

    case 22 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      val child21 = children(21)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      lazy val converter21 = CatalystTypeConverters.createToScalaConverter(child21.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)),
          converter21(child21.eval(input)))
      }
  }

  // Generate codes used to convert the arguments to Scala type for user-defined funtions
  private[this] def genCodeForConverter(ctx: CodeGenContext, index: Int): String  = {
    val converterClassName = classOf[Any => Any].getName
    val typeConvertersClassName = CatalystTypeConverters.getClass.getName + ".MODULE$"
    val expressionClassName = classOf[Expression].getName
    val scalaUDFClassName = classOf[ScalaUDF].getName

    val converterTerm = ctx.freshName("converter" + index.toString)
    ctx.addMutableState(converterClassName, converterTerm,
      s"this.$converterTerm = ($converterClassName)$typeConvertersClassName.createToScalaConverter(((${expressionClassName})((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).getChildren().apply($index))).dataType());")
    converterTerm
  }

  override def genCode(
      ctx: CodeGenContext,
      ev: GeneratedExpressionCode): String = {

    ctx.references += this

    val scalaUDFClassName = classOf[ScalaUDF].getName
    val converterClassName = classOf[Any => Any].getName
    val typeConvertersClassName = CatalystTypeConverters.getClass.getName + ".MODULE$"
    val expressionClassName = classOf[Expression].getName

    // Generate codes used to convert the returned value of user-defined functions to Catalyst type
    val catalystConverterTerm = ctx.freshName("catalystConverter")
    ctx.addMutableState(converterClassName, catalystConverterTerm,
      s"this.$catalystConverterTerm = ($converterClassName)$typeConvertersClassName.createToCatalystConverter((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).dataType());")

    val resultTerm = ctx.freshName("result")

    val (evalCode, callFunc) = children.size match {
      case 0 =>
        val funcClassName = classOf[() => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply());"
        ("", callFunc)

      case 1 =>
        // This must be called before children expressions' codegen because ctx.references is used in genCodeForConverter
        val converterTerms = (0 until 1).map(genCodeForConverter(ctx, _))

        // Initialize user-defined function
        val funcClassName = classOf[(Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)

        // Generate the codes for expressions and calling user-defined function
        // We need to get the boxedType of dataType's javaType here. Because for the dataType
        // such as IntegerType, its javaType is `int` and the returned type of user-defined
        // function is Object. Trying to convert an Object to `int` will cause casting exception.
        val evalCode = eval0.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value})));"
        (evalCode, callFunc)

      case 2 =>
        val converterTerms = (0 until 2).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)

        val evalCode = eval0.code + eval1.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value})));"
        (evalCode, callFunc)

      case 3 =>
        val converterTerms = (0 until 3).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value})));"
        (evalCode, callFunc)

      case 4 =>
        val converterTerms = (0 until 4).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value})));"
        (evalCode, callFunc)

      case 5 =>
        val converterTerms = (0 until 5).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value})));"
        (evalCode, callFunc)

      case 6 =>
        val converterTerms = (0 until 6).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value})));"
        (evalCode, callFunc)

      case 7 =>
        val converterTerms = (0 until 7).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value})));"
        (evalCode, callFunc)

      case 8 =>
        val converterTerms = (0 until 8).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value})));"
        (evalCode, callFunc)

      case 9 =>
        val converterTerms = (0 until 9).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value})));"
        (evalCode, callFunc)

      case 10 =>
        val converterTerms = (0 until 10).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value})));"
        (evalCode, callFunc)

      case 11 =>
        val converterTerms = (0 until 11).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value})));"
        (evalCode, callFunc)

      case 12 =>
        val converterTerms = (0 until 12).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value})));"
        (evalCode, callFunc)

      case 13 =>
        val converterTerms = (0 until 13).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value})));"
        (evalCode, callFunc)

      case 14 =>
        val converterTerms = (0 until 14).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value})));"
        (evalCode, callFunc)

      case 15 =>
        val converterTerms = (0 until 15).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value})));"
        (evalCode, callFunc)

      case 16 =>
        val converterTerms = (0 until 16).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value})));"
        (evalCode, callFunc)

      case 17 =>
        val converterTerms = (0 until 17).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value})));"
        (evalCode, callFunc)

      case 18 =>
        val converterTerms = (0 until 18).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)
        val child17 = children(17)
        val eval17 = child17.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code + eval17.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value}), ${converterTerms(17)}.apply(${eval17.value})));"
        (evalCode, callFunc)

      case 19 =>
        val converterTerms = (0 until 19).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)
        val child17 = children(17)
        val eval17 = child17.gen(ctx)
        val child18 = children(18)
        val eval18 = child18.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code + eval17.code + eval18.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value}), ${converterTerms(17)}.apply(${eval17.value}), ${converterTerms(18)}.apply(${eval18.value})));"
        (evalCode, callFunc)

      case 20 =>
        val converterTerms = (0 until 20).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)
        val child17 = children(17)
        val eval17 = child17.gen(ctx)
        val child18 = children(18)
        val eval18 = child18.gen(ctx)
        val child19 = children(19)
        val eval19 = child19.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code + eval17.code + eval18.code + eval19.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value}), ${converterTerms(17)}.apply(${eval17.value}), ${converterTerms(18)}.apply(${eval18.value}), ${converterTerms(19)}.apply(${eval19.value})));"
        (evalCode, callFunc)

      case 21 =>
        val converterTerms = (0 until 21).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)
        val child17 = children(17)
        val eval17 = child17.gen(ctx)
        val child18 = children(18)
        val eval18 = child18.gen(ctx)
        val child19 = children(19)
        val eval19 = child19.gen(ctx)
        val child20 = children(20)
        val eval20 = child20.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code + eval17.code + eval18.code + eval19.code + eval20.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value}), ${converterTerms(17)}.apply(${eval17.value}), ${converterTerms(18)}.apply(${eval18.value}), ${converterTerms(19)}.apply(${eval19.value}), ${converterTerms(20)}.apply(${eval20.value})));"
        (evalCode, callFunc)

      case 22 =>
        val converterTerms = (0 until 22).map(genCodeForConverter(ctx, _))

        val funcClassName = classOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any].getName
        val funcTerm = ctx.freshName("udf")
        ctx.addMutableState(funcClassName, funcTerm,
          s"this.$funcTerm = ($funcClassName)((($scalaUDFClassName)expressions[${ctx.references.size - 1}]).userDefinedFunc());")

        val child0 = children(0)
        val eval0 = child0.gen(ctx)
        val child1 = children(1)
        val eval1 = child1.gen(ctx)
        val child2 = children(2)
        val eval2 = child2.gen(ctx)
        val child3 = children(3)
        val eval3 = child3.gen(ctx)
        val child4 = children(4)
        val eval4 = child4.gen(ctx)
        val child5 = children(5)
        val eval5 = child5.gen(ctx)
        val child6 = children(6)
        val eval6 = child6.gen(ctx)
        val child7 = children(7)
        val eval7 = child7.gen(ctx)
        val child8 = children(8)
        val eval8 = child8.gen(ctx)
        val child9 = children(9)
        val eval9 = child9.gen(ctx)
        val child10 = children(10)
        val eval10 = child10.gen(ctx)
        val child11 = children(11)
        val eval11 = child11.gen(ctx)
        val child12 = children(12)
        val eval12 = child12.gen(ctx)
        val child13 = children(13)
        val eval13 = child13.gen(ctx)
        val child14 = children(14)
        val eval14 = child14.gen(ctx)
        val child15 = children(15)
        val eval15 = child15.gen(ctx)
        val child16 = children(16)
        val eval16 = child16.gen(ctx)
        val child17 = children(17)
        val eval17 = child17.gen(ctx)
        val child18 = children(18)
        val eval18 = child18.gen(ctx)
        val child19 = children(19)
        val eval19 = child19.gen(ctx)
        val child20 = children(20)
        val eval20 = child20.gen(ctx)
        val child21 = children(21)
        val eval21 = child21.gen(ctx)

        val evalCode = eval0.code + eval1.code + eval2.code + eval3.code + eval4.code + eval5.code + eval6.code + eval7.code + eval8.code + eval9.code + eval10.code + eval11.code + eval12.code + eval13.code + eval14.code + eval15.code + eval16.code + eval17.code + eval18.code + eval19.code + eval20.code + eval21.code
        val callFunc = s"${ctx.boxedType(ctx.javaType(dataType))} $resultTerm = (${ctx.boxedType(ctx.javaType(dataType))})${catalystConverterTerm}.apply($funcTerm.apply(${converterTerms(0)}.apply(${eval0.value}), ${converterTerms(1)}.apply(${eval1.value}), ${converterTerms(2)}.apply(${eval2.value}), ${converterTerms(3)}.apply(${eval3.value}), ${converterTerms(4)}.apply(${eval4.value}), ${converterTerms(5)}.apply(${eval5.value}), ${converterTerms(6)}.apply(${eval6.value}), ${converterTerms(7)}.apply(${eval7.value}), ${converterTerms(8)}.apply(${eval8.value}), ${converterTerms(9)}.apply(${eval9.value}), ${converterTerms(10)}.apply(${eval10.value}), ${converterTerms(11)}.apply(${eval11.value}), ${converterTerms(12)}.apply(${eval12.value}), ${converterTerms(13)}.apply(${eval13.value}), ${converterTerms(14)}.apply(${eval14.value}), ${converterTerms(15)}.apply(${eval15.value}), ${converterTerms(16)}.apply(${eval16.value}), ${converterTerms(17)}.apply(${eval17.value}), ${converterTerms(18)}.apply(${eval18.value}), ${converterTerms(19)}.apply(${eval19.value}), ${converterTerms(20)}.apply(${eval20.value}), ${converterTerms(21)}.apply(${eval21.value})));"
        (evalCode, callFunc)

      case _ =>
        throw new UnsupportedOperationException(
          "ScalaUDF doesn't support user-defined functions with more than 22 arguments")
    }

    evalCode + s"""
      ${ctx.javaType(dataType)} ${ev.value} = ${ctx.defaultValue(dataType)};
      Boolean ${ev.isNull};

      $callFunc

      ${ev.value} = $resultTerm;
      ${ev.isNull} = $resultTerm == null;
    """
  }

  // scalastyle:on
  private[this] val converter = CatalystTypeConverters.createToCatalystConverter(dataType)
  override def eval(input: InternalRow): Any = converter(f(input))
}
