-- Automatically generated by SQLQueryTestSuite
-- !query
CREATE TEMPORARY VIEW t1 AS SELECT * FROM VALUES (0, 0), (1, 1), (2, 2) AS t(c1, c2)
-- !query schema
struct<>
-- !query output



-- !query
CREATE TEMPORARY VIEW t2 AS
WITH v as (
  SELECT c1 + c1 c3 FROM t1
)
SELECT SUM(c3) s FROM v
-- !query schema
struct<>
-- !query output



-- !query
CACHE TABLE cache_table
WITH
t2 AS (SELECT 1)
SELECT * FROM t2
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM cache_table
-- !query schema
struct<1:int>
-- !query output
1


-- !query
EXPLAIN EXTENDED SELECT * FROM cache_table
-- !query schema
struct<plan:string>
-- !query output
== Parsed Logical Plan ==
'Project [*]
+- 'UnresolvedRelation [cache_table], [], false

== Analyzed Logical Plan ==
1: int
Project [1#x]
+- SubqueryAlias cache_table
   +- View (`cache_table`, [1#x])
      +- Project [cast(1#x as int) AS 1#x]
         +- WithCTE
            :- CTERelationDef xxxx, false
            :  +- SubqueryAlias t2
            :     +- Project [1 AS 1#x]
            :        +- OneRowRelation
            +- Project [1#x]
               +- SubqueryAlias t2
                  +- CTERelationRef xxxx, true, [1#x], false

== Optimized Logical Plan ==
InMemoryRelation [1#x], StorageLevel(disk, memory, deserialized, 1 replicas)
   +- *Project [1 AS 1#x]
      +- *Scan OneRowRelation[]

== Physical Plan ==
Scan In-memory table cache_table [1#x]
   +- InMemoryRelation [1#x], StorageLevel(disk, memory, deserialized, 1 replicas)
         +- *Project [1 AS 1#x]
            +- *Scan OneRowRelation[]


-- !query
CACHE TABLE cache_nested_cte_table
WITH
v AS (
  SELECT c1 * c2 c3 from t1
)
SELECT SUM(c3) FROM v
EXCEPT
SELECT s FROM t2
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM cache_nested_cte_table
-- !query schema
struct<sum(c3):bigint>
-- !query output
5


-- !query
EXPLAIN EXTENDED SELECT * FROM cache_nested_cte_table
-- !query schema
struct<plan:string>
-- !query output
== Parsed Logical Plan ==
'Project [*]
+- 'UnresolvedRelation [cache_nested_cte_table], [], false

== Analyzed Logical Plan ==
sum(c3): bigint
Project [sum(c3)#xL]
+- SubqueryAlias cache_nested_cte_table
   +- View (`cache_nested_cte_table`, [sum(c3)#xL])
      +- Project [cast(sum(c3)#xL as bigint) AS sum(c3)#xL]
         +- WithCTE
            :- CTERelationDef xxxx, false
            :  +- SubqueryAlias v
            :     +- Project [(c1#x * c2#x) AS c3#x]
            :        +- SubqueryAlias t1
            :           +- View (`t1`, [c1#x, c2#x])
            :              +- Project [cast(c1#x as int) AS c1#x, cast(c2#x as int) AS c2#x]
            :                 +- Project [c1#x, c2#x]
            :                    +- SubqueryAlias t
            :                       +- LocalRelation [c1#x, c2#x]
            +- Except false
               :- Aggregate [sum(c3#x) AS sum(c3)#xL]
               :  +- SubqueryAlias v
               :     +- CTERelationRef xxxx, true, [c3#x], false
               +- Project [s#xL]
                  +- SubqueryAlias t2
                     +- View (`t2`, [s#xL])
                        +- Project [cast(s#xL as bigint) AS s#xL]
                           +- WithCTE
                              :- CTERelationDef xxxx, false
                              :  +- SubqueryAlias v
                              :     +- Project [(c1#x + c1#x) AS c3#x]
                              :        +- SubqueryAlias t1
                              :           +- View (`t1`, [c1#x, c2#x])
                              :              +- Project [cast(c1#x as int) AS c1#x, cast(c2#x as int) AS c2#x]
                              :                 +- Project [c1#x, c2#x]
                              :                    +- SubqueryAlias t
                              :                       +- LocalRelation [c1#x, c2#x]
                              +- Aggregate [sum(c3#x) AS s#xL]
                                 +- SubqueryAlias v
                                    +- CTERelationRef xxxx, true, [c3#x], false

== Optimized Logical Plan ==
InMemoryRelation [sum(c3)#xL], StorageLevel(disk, memory, deserialized, 1 replicas)
   +- AdaptiveSparkPlan isFinalPlan=true
      +- == Final Plan ==
         *BroadcastHashJoin [coalesce(sum(c3)#xL, 0), isnull(sum(c3)#xL)], [coalesce(s#xL, 0), isnull(s#xL)], LeftAnti, BuildRight, false
         :- *HashAggregate(keys=[], functions=[sum(c3#x)], output=[sum(c3)#xL])
         :  +- ShuffleQueryStage 0
         :     +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
         :        +- *HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
         :           +- *Project [(c1#x * c2#x) AS c3#x]
         :              +- *LocalTableScan [c1#x, c2#x]
         +- BroadcastQueryStage 2
            +- BroadcastExchange HashedRelationBroadcastMode(List(coalesce(input[0, bigint, true], 0), isnull(input[0, bigint, true])),false), [plan_id=x]
               +- *HashAggregate(keys=[], functions=[sum(c3#x)], output=[s#xL])
                  +- ShuffleQueryStage 1
                     +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                        +- *HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                           +- *Project [(c1#x + c1#x) AS c3#x]
                              +- *LocalTableScan [c1#x, c2#x]
      +- == Initial Plan ==
         BroadcastHashJoin [coalesce(sum(c3)#xL, 0), isnull(sum(c3)#xL)], [coalesce(s#xL, 0), isnull(s#xL)], LeftAnti, BuildRight, false
         :- HashAggregate(keys=[], functions=[sum(c3#x)], output=[sum(c3)#xL])
         :  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
         :     +- HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
         :        +- Project [(c1#x * c2#x) AS c3#x]
         :           +- LocalTableScan [c1#x, c2#x]
         +- BroadcastExchange HashedRelationBroadcastMode(List(coalesce(input[0, bigint, true], 0), isnull(input[0, bigint, true])),false), [plan_id=x]
            +- HashAggregate(keys=[], functions=[sum(c3#x)], output=[s#xL])
               +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                  +- HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                     +- Project [(c1#x + c1#x) AS c3#x]
                        +- LocalTableScan [c1#x, c2#x]

== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- Scan In-memory table cache_nested_cte_table [sum(c3)#xL]
      +- InMemoryRelation [sum(c3)#xL], StorageLevel(disk, memory, deserialized, 1 replicas)
            +- AdaptiveSparkPlan isFinalPlan=true
               +- == Final Plan ==
                  *BroadcastHashJoin [coalesce(sum(c3)#xL, 0), isnull(sum(c3)#xL)], [coalesce(s#xL, 0), isnull(s#xL)], LeftAnti, BuildRight, false
                  :- *HashAggregate(keys=[], functions=[sum(c3#x)], output=[sum(c3)#xL])
                  :  +- ShuffleQueryStage 0
                  :     +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                  :        +- *HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                  :           +- *Project [(c1#x * c2#x) AS c3#x]
                  :              +- *LocalTableScan [c1#x, c2#x]
                  +- BroadcastQueryStage 2
                     +- BroadcastExchange HashedRelationBroadcastMode(List(coalesce(input[0, bigint, true], 0), isnull(input[0, bigint, true])),false), [plan_id=x]
                        +- *HashAggregate(keys=[], functions=[sum(c3#x)], output=[s#xL])
                           +- ShuffleQueryStage 1
                              +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                                 +- *HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                                    +- *Project [(c1#x + c1#x) AS c3#x]
                                       +- *LocalTableScan [c1#x, c2#x]
               +- == Initial Plan ==
                  BroadcastHashJoin [coalesce(sum(c3)#xL, 0), isnull(sum(c3)#xL)], [coalesce(s#xL, 0), isnull(s#xL)], LeftAnti, BuildRight, false
                  :- HashAggregate(keys=[], functions=[sum(c3#x)], output=[sum(c3)#xL])
                  :  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                  :     +- HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                  :        +- Project [(c1#x * c2#x) AS c3#x]
                  :           +- LocalTableScan [c1#x, c2#x]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(coalesce(input[0, bigint, true], 0), isnull(input[0, bigint, true])),false), [plan_id=x]
                     +- HashAggregate(keys=[], functions=[sum(c3#x)], output=[s#xL])
                        +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
                           +- HashAggregate(keys=[], functions=[partial_sum(c3#x)], output=[sum#xL])
                              +- Project [(c1#x + c1#x) AS c3#x]
                                 +- LocalTableScan [c1#x, c2#x]


-- !query
DROP TABLE IF EXISTS t1
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE IF EXISTS t2
-- !query schema
struct<>
-- !query output

