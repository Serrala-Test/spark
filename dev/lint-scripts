#!/usr/bin/env bash

#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
SPARK_ROOT_DIR="$(dirname $SCRIPT_DIR)"
# TARGET_PATHS can contain directories and files.
TARGET_PATHS=("$SPARK_ROOT_DIR/bin" "$SPARK_ROOT_DIR/sbin" "$SPARK_ROOT_DIR/dev")
LOG_FILE=lint-scripts.txt
HAS_ERROR=0

# Check whether all of lines ends properly.
function check_eol_style() {
  has_eol_style_error=0
  files="$1"

  # Assume the file which have the suffix ".bat" or ".cmd" is Windows batch file.
  bat_files=`echo "$files" | grep "^.*\.\(cmd\|bat\)$"`
  has_bat_eol_error=0
  for bat_file in $bat_files; do
    if [ ! -f "$bat_file" ]; then
      continue
    fi

    line=`grep -v -nU $'\r' "$bat_file"`
    if [ "$?" -eq 0 ]; then
      # Error header should be print only once.
      if [ "$has_bat_eol_error" -eq 0 ]; then
        echo "Non-Windows-style line endings were found at the following location(s):" >> "$LOG_FILE"
        has_bat_eol_error=1
        HAS_ERROR=1
      fi
      echo "========================== $bat_file ==========================" >> "$LOG_FILE"
      echo "$line" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
    fi
  done

  if [ "$has_bat_eol_error" -eq 1 ]; then
    echo "Please fix the line endings to follow the Windows convention of CR/LF." >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
  fi

  sh_files=`echo "$files" | grep -v "^.*\.\(cmd\|bat\)$"`
  has_sh_eol_error=0
  for sh_file in $sh_files; do
    if [ ! -f "$sh_file" ]; then
      continue
    fi

    line=`grep -nU $'\r' "$sh_file"`
    if [ "$?" -eq 0 ];then
      if [ "$has_sh_eol_error" -eq 0 ]; then
        echo "Non-Linux/Mac-style line endings were found at the following location(s):" >> "$LOG_FILE"
        has_sh_eol_error=1
        HAS_ERROR=1
      fi
      echo "========================== $sh_file ==========================" >> "$LOG_FILE"
      echo "$line" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
    fi
  done

  if [ "$has_sh_eol_error" -eq 1 ]; then
    echo "Please fix the line endings to follow the Linux/Mac convention of LF." >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
  fi
}

# Check tab-space
function check_tabs() {
  has_tabs_error=0
  files="$1"

  for f in $files; do
    if [ ! -f "$f" ]; then
      continue
    fi
    line=`grep -nU $'\t' "$f"`
    if [ "$?" -eq 0 ]; then
      if [ "$has_tabs_error" -eq 0 ]; then
        echo "Tab spaces were found at following location(s):" >> "$LOG_FILE"
        has_tabs_error=1
        HAS_ERROR=1
      fi
      echo "========================== $f ==========================" >> "$LOG_FILE"
      echo "$line" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
    fi
  done
}

# Check white spaces before EOL
function check_white_spaces_before_eol() {
  has_tabs_error=0
  files="$1"

  for f in $files; do
    if [ ! -f "$f" ]; then
      continue
    fi
    line=`grep -nU "[ ]\+$" "$f"`

    if [ "$?" -eq 0 ]; then
      if [ "$has_tabs_error" -eq 0 ]; then
        echo "Spaces were found before EOL at following location(s):" >> "$LOG_FILE"
        has_tabs_error=1
        HAS_ERROR=1
      fi
      echo "========================== $f ==========================" >> "$LOG_FILE"
      echo "$line" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
    fi
  done
}

# Check Non-ASCII characters
function check_multibyte_character() {
  has_mbyte_char_error=0
  files="$1"

  for f in $files; do
    if [ ! -f "$f" ]; then
      continue
    fi

    # [:alnum:] couldn't work well so we use a-zA-Z0-9
    line=`grep -nU "[^ a-zA-Z0-9[:space:][:punct:]]" "$f"`

    if [ "$?" -eq 0 ]; then
      if [ "$has_mbyte_char_error" -eq 0 ]; then
        echo "Spaces were found before EOL at following location(s):" >> "$LOG_FILE"
        has_mbyte_char_error=1
        HAS_ERROR=1
      fi
      echo "========================== $f ==========================" >> "$LOG_FILE"
      echo "$line" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
    fi
  done
}

# if path represents a directory, we can check files in the directory.
# else, path is checked as a regular file.
for path in "${TARGET_PATHS[@]}"; do
  if [ -d "$path" ]; then
    files=`ls -d "$path/"*`
  elif [ -f "$path" ]; then
    files=`ls "$path"`
  fi

  # We handle the case when path represents a directory or a regular file.
  if [ -n "$files" ]; then
    check_eol_style "$files"
    check_tabs  "$files"
    check_white_spaces_before_eol "$files"
    check_multibyte_character "$files"
  fi
done

if [ "$HAS_ERROR" -eq "1" ]; then
    echo "Script style checks failed."
    cat "$LOG_FILE"
  else
  echo "Scripts style checks passed."
fi

if [ -f "$LOG_FILE" ]; then
  rm "$LOG_FILE"
fi

exit "$HAS_ERROR"
